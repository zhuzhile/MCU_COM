C51 COMPILER V9.60.0.0   MASTER                                                            05/22/2022 17:04:38 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MASTER
OBJECT MODULE PLACED IN Master.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Master.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include <reg52.h>
   2          #include <stdlib.h>
   3          #include "KeyScan.h"
   4          #include "Delay.h"
   5          #include "LCD1602.h"
   6          
   7          #define uint unsigned int
   8          #define uchar unsigned char
   9          
  10          sbit LED=P2^3;
  11          sbit RS485_TR=P3^2;
  12          
  13          #define TXEN RS485_TR=1; //发送使能
  14          #define RXEN RS485_TR=0; //接收使能
  15          #define OSC 12000000
  16          #define BAUDRATE 4800
  17          
  18          
  19          bit R_done = 0;  // 判断接收是否完成
  20          bit T_done = 0;  // 判断发送是否完成
  21          bit Succ = 1;    // 判断接收数据是否有效（数据长度为0则无效）
  22          
  23          uint TPtr,RPtr; // 接收与发送指针
  24          uint len,check; // 数据长度，校验结果
  25          uint time_count = 0; //延迟时间计数
  26          uchar R_buf[10];  //接收数据缓存
  27          uchar T_buf[10]; //发送数据缓存
  28          uchar H_addr = 0x00; //主机地址
  29          uchar T_addr= 0x01; //发送地址
  30          uchar T_data= 0x00; //发送数据
  31          uchar R_addr = 0x00; //接收从机地址
  32          uchar send_addr_counter = 0; //发送地址次数
  33          
  34          void mock_data();
  35          void show_data(uchar TR_data);
  36          void send_addr();
  37          void show_endline(char addr, uint index);
  38          void send_data();
  39          void handle_key();
  40          void serial_init();
  41          void show_headline();
  42          void timer0_init();
  43          void show_test_data(uchar index, uchar TR_data);
  44          void send_stop_signal();
  45          uint create_stop_check(); // 创造停止校验位
  46          
  47          void main(){
  48   1        serial_init();
  49   1        LCD_init();
  50   1        
  51   1        T_addr = 0x01; //默认发送地址为从机1
  52   1        T_data = 0;
  53   1        
  54   1        while(1){
  55   2          show_headline();
C51 COMPILER V9.60.0.0   MASTER                                                            05/22/2022 17:04:38 PAGE 2   

  56   2          handle_key();
  57   2        }
  58   1      }
  59          
  60          
  61          void mock_data(){ // 模拟发送数据
  62   1        uint i;
  63   1        T_buf[0] = H_addr;
  64   1        T_buf[1] = T_addr;
  65   1        T_buf[2] = len;
  66   1        for(i = 0; i < len;i++){
  67   2          T_buf[3 + i] = T_data;
  68   2        }
  69   1        check = T_buf[0];
  70   1        for(i = 1; i < len + 3; i++){
  71   2            check ^= T_buf[i];
  72   2        }
  73   1        
  74   1        T_buf[3 + len] = check;
  75   1      }
  76          
  77          void show_data(uchar TR_data){
  78   1          write_data('0'+TR_data/100);
  79   1          write_data('0'+TR_data/10%10);
  80   1          write_data('0'+TR_data%10); 
  81   1      }
  82          
  83          void show_test_data(uchar index,uchar TR_data){
  84   1        switch(index){
  85   2          case 0:
  86   2            show_string(2, 9, "_T_"); //发送数据标志
  87   2            delay(1000);
  88   2            show_num(2, 9, TR_data, 3);
  89   2            break;
  90   2          case 1:
  91   2            show_string(2, 9, "_R_"); //接收数据标志
  92   2            delay(1000);
  93   2            show_num(2, 9, TR_data, 3);
  94   2            break;
  95   2          case 2:
  96   2            show_string(2, 9, "TD_"); //发送数据完成标志
  97   2            delay(1000);
  98   2            show_num(2, 9, TR_data, 3);
  99   2            break;
 100   2          case 3:
 101   2            show_string(2, 9, "RD_"); //接收数据完成标志
 102   2            delay(1000);
 103   2            show_num(2, 9, TR_data, 3);
 104   2            break;
 105   2          case 4:
 106   2            show_string(2, 9, "RA_"); //接收地址标志
 107   2            delay(1000);
 108   2            show_num(2, 9, TR_data, 3);
 109   2            break;
 110   2          case 5:
 111   2            show_string(2, 9, "TA_"); //发送地址标志
 112   2            delay(1000);
 113   2            show_num(2, 9, TR_data, 3);
 114   2            break;
 115   2          case 6:
 116   2            show_string(2, 9, "RTA"); //重新发送地址标志
 117   2            delay(1000);
C51 COMPILER V9.60.0.0   MASTER                                                            05/22/2022 17:04:38 PAGE 3   

 118   2            show_num(2, 9, TR_data, 3);
 119   2            break;
 120   2          case 7:
 121   2            show_string(2, 9, "RT_"); //重新发送数据标志
 122   2            delay(1000);
 123   2            show_num(2, 9, TR_data, 3);
 124   2            break;
 125   2        }
 126   1      }
 127          
 128          
 129          void send_addr(){ 
 130   1        uchar index;
 131   1        TXEN;
 132   1        TI = 0;
 133   1        TB8 = 1;
 134   1        SBUF = T_addr;
 135   1        while(!TI);
 136   1        TI = 0;
 137   1        index = send_addr_counter == 0 ? 5 : 6;
 138   1        show_test_data(index, T_addr); // 测试代码
 139   1        delay(1000);
 140   1        
 141   1        RXEN;
 142   1        RI = 0;
 143   1        
 144   1        delay(2000);
 145   1        
 146   1        time_count = 0;
 147   1        timer0_init();
 148   1        while(time_count < 7); //等待7ms过后
 149   1        time_count = 0;
 150   1        
 151   1        
 152   1        if(R_addr != T_addr){
 153   2      //    delay(100);  //与从机同步
 154   2          send_addr_counter ++;
 155   2          send_addr();
 156   2        }
 157   1        
 158   1      }
 159          
 160          void show_endline(uchar addr, uint index){
 161   1          write_command(0x80+0x40); 
 162   1          write_data('R');
 163   1          
 164   1          write_data('0' + addr);
 165   1          write_data(':');
 166   1          show_data(R_buf[index]);
 167   1      }
 168          
 169          void send_data(){
 170   1          TXEN;
 171   1          TI = 0;
 172   1          TB8 = 0;
 173   1          TPtr = 0;
 174   1          TI = 1;
 175   1        
 176   1          while(!T_done); 
 177   1          T_done = 0;
 178   1          
 179   1        
C51 COMPILER V9.60.0.0   MASTER                                                            05/22/2022 17:04:38 PAGE 4   

 180   1          RXEN;           //开始接收数据
 181   1          RI = 0;
 182   1          R_done = 0;
 183   1          RPtr = 0;
 184   1        
 185   1          while(!R_done );
 186   1          R_done = 0;   
 187   1      }
 188          
 189          
 190          void handle_key(){
 191   1        uchar k = 0;
 192   1        k = getKeyNum();
 193   1        switch(k)
 194   1        {
 195   2          case 1:
 196   2            T_addr = T_addr != 0x01 ? 0x01 : 0x02;  
 197   2            break;
 198   2          case 2:
 199   2            T_data ++;
 200   2            break;
 201   2          case 3:
 202   2            T_data --;
 203   2            break;
 204   2          case 4: 
 205   2            send_addr();
 206   2          
 207   2            len = rand() % 5 + 1;
 208   2            
 209   2            TB8 = 0; // 开始发送数据
 210   2            SM2 = 0;
 211   2            mock_data();  
 212   2            send_data();   
 213   2            
 214   2            while(!Succ){       // 如果接收的数据有错误，重新发送
 215   3              send_data();
 216   3            }
 217   2            
 218   2            show_endline(T_addr, 2); // 如果接收的数据没有问题，显示发送的数据
 219   2            send_stop_signal(); // 开始发送长度为0数据，表示发送终止
 220   2            while(!T_done);
 221   2            T_done = 0;
 222   2            break;
 223   2        }
 224   1      }
 225          
 226          uint create_stop_check(){ 
 227   1        uint i = 0, stop_check = T_buf[0];
 228   1        
 229   1        for( i = 1; i < 3; i++){
 230   2          stop_check ^= T_buf[i];
 231   2        }
 232   1        
 233   1        return stop_check;
 234   1      }
 235          
 236          void send_stop_signal(){
 237   1          TXEN;
 238   1          TI = 0;
 239   1          TB8 = 0;
 240   1          T_buf[2] = 0;
 241   1        
C51 COMPILER V9.60.0.0   MASTER                                                            05/22/2022 17:04:38 PAGE 5   

 242   1          T_buf[3] = create_stop_check();
 243   1          TI = 1;
 244   1          while(!T_done);
 245   1      }
 246          
 247          
 248          void serial_init(){
 249   1        TMOD = 0x20; // 定时器1，工作模式2
 250   1        TL1 = 256 - (OSC / BAUDRATE / 12 / 16); // 硬件自动重载
 251   1        TH1 = 256 - (OSC / BAUDRATE / 12 / 16);
 252   1        PCON |= 0X80;
 253   1        TR1 = 1; // 开启计数
 254   1        SCON = 0xD8; // 串口3，TB8为1，REN为1 
 255   1        EA = 1;
 256   1        ES = 1;
 257   1      }
 258          
 259          void timer0_init(){
 260   1        TMOD &= 0xF0;
 261   1        TMOD |= 0x01;
 262   1        TF0 = 0;
 263   1        TR0 = 1; 
 264   1        TH0 = (65535 - 1000)/256;
 265   1        TL0 = (65535 - 1000)%256;
 266   1        ET0 = 1;
 267   1        PT0 = 1;
 268   1        EA = 1;
 269   1      }
 270          
 271          
 272          void show_headline(){
 273   1          write_command(0x80);
 274   1          write_data('T');
 275   1          write_command(0x80+3);
 276   1          write_data('A');
 277   1          write_data(':');
 278   1          write_data('0' + T_addr); 
 279   1          write_command(0x80+8);
 280   1          write_data('D');
 281   1          write_data(':');
 282   1          show_data(T_data);
 283   1      }
 284          
 285          
 286          void comISR()interrupt 4{ // 通信串口中断服务
 287   1        
 288   1        if( TI == 1 && TB8 == 0){
 289   2          uchar index;
 290   2          TI = 0;
 291   2          
 292   2          if(!T_done){
 293   3            TB8 = 0;
 294   3            SBUF = T_buf[TPtr++];
 295   3            
 296   3            index = Succ ? 0 : 7;
 297   3            show_test_data(index, T_buf[TPtr - 1]); //测试代码
 298   3            delay(1000);
 299   3            
 300   3            if(TPtr >=  T_buf[2] + 4){
 301   4              
 302   4              show_test_data(2, TPtr); //测试代码
 303   4              delay(1000);
C51 COMPILER V9.60.0.0   MASTER                                                            05/22/2022 17:04:38 PAGE 6   

 304   4          
 305   4        //      delay(100); //保持主从同步
 306   4              
 307   4              T_done = 1;
 308   4              TPtr = 0;
 309   4              Succ = 1;
 310   4              send_addr_counter = 0;
 311   4            }
 312   3          } 
 313   2        }
 314   1        
 315   1        if(RI == 1){  
 316   2          RI = 0;
 317   2          if(RB8 == 0){
 318   3            R_buf[RPtr++] = SBUF;
 319   3            
 320   3            show_test_data(1, R_buf[RPtr - 1]); //测试代码
 321   3            delay(1000);
 322   3      
 323   3            if( RPtr >= 3 + R_buf[1]){ //从机地址+数据长度+数据+校验和
 324   4              
 325   4                show_test_data(3, RPtr); //测试代码
 326   4                delay(1000);
 327   4              
 328   4                R_done = 1;
 329   4                Succ = R_buf[1] == 0 ? 0 : 1;
 330   4            }
 331   3          }
 332   2          
 333   2          if(RB8 == 1){
 334   3              R_addr = SBUF;
 335   3          }
 336   2        }
 337   1      }
 338          
 339          
 340          void timer0ISR() interrupt 1{ // 定时器0中断服务timer 
 341   1        time_count ++;
 342   1        timer0_init();
 343   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    944    ----
   CONSTANT SIZE    =     32    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     35       6
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

C51 COMPILER V9.60.0.0   SLAVE1                                                            05/23/2022 22:18:06 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE SLAVE1
OBJECT MODULE PLACED IN Slave1.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Slave1.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include <reg52.h>
   2          #include "LCD1602.h"
   3          #include "Delay.h"
   4          
   5          #define uchar unsigned char 
   6          #define uint unsigned int
   7          #define OSC 12000000
   8          #define BAUDRATE 4800
   9          
  10          uchar R_buf[10],T_buf[10];    //接收数据缓存
  11          uint RPtr, TPtr; // 接收与发送指针
  12          uchar check, len, R_check; // 校验位和数据长度
  13          uchar slave_addr = 0x01; // 本机地址 
  14          uchar R_addr = 0x00;    // 接收到地址
  15          uint time_count = 0; //计时
  16          bit Succ = 1; //判断从机是否接收成功
  17          bit R_done = 0; // 接收完成
  18          bit T_done = 0 ;// 发送完成
  19          bit A_acc = 0; // 判断地址有效
  20          sbit LED = P2^3;
  21          sbit RS485_TR = P3^2;
  22          
  23          #define TXEN RS485_TR=1 //发送使能
  24          #define RXEN RS485_TR=0 //接收使能
  25          
  26          
  27          void serial_init(){
  28   1        TMOD = 0X20; // 定时器1选择模式2，8位自动重载
  29   1        TL1 = 256 - (OSC / BAUDRATE / 12 / 16); // 硬件自动重载
  30   1        TH1 = 256 - (OSC / BAUDRATE / 12 / 16);
  31   1        TR1 = 1;     // 开启计数
  32   1        SCON = 0xF0; // 串口工作方式3
  33   1        PCON |= 0x80;
  34   1        EA = 1;
  35   1        ES = 1;
  36   1        RXEN;
  37   1      }
  38          
  39          
  40          
  41          void timer0_init(){
  42   1        TMOD &= 0xF0;
  43   1        TMOD |= 0x01;
  44   1        TF0 = 0;
  45   1        TR0 = 1; 
  46   1        TH0 = (65535 - 1000)/256;
  47   1        TL0 = (65535 - 1000)%256;
  48   1        ET0 = 1;
  49   1        PT0 = 1;
  50   1        EA = 1;
  51   1      }
  52          
  53          void show_test_data(TR_data){
  54   1        
  55   1        write_command(0x80+0x40);
C51 COMPILER V9.60.0.0   SLAVE1                                                            05/23/2022 22:18:06 PAGE 2   

  56   1        write_data('D');
  57   1        write_data(':');
  58   1        write_data('0'+TR_data/100);
  59   1        write_data('0'+TR_data/10%10);
  60   1        write_data('0'+TR_data%10);
  61   1      }
  62          
  63          
  64          void show_data(TR_data){  // 显示数据
  65   1        write_command(0x80+2);
  66   1        write_data('0'+TR_data/100);
  67   1        write_data('0'+TR_data/10%10);
  68   1        write_data('0'+TR_data%10);
  69   1      }
  70          
  71          void mock_data(){
  72   1        uint i = 0,len_data = R_buf[2] + 3;
  73   1        
  74   1        for( i = 0; i < len_data;i ++){
  75   2          if(!Succ && i == 1){
  76   3            T_buf[i] = 0;
  77   3            break;
  78   3          }
  79   2          T_buf[i] = R_buf[i + 1];
  80   2        }
  81   1        
  82   1        check = T_buf[0];
  83   1        len_data = T_buf[1] == 0 ? 2: T_buf[1] + 3;
  84   1        
  85   1        for( i = 1 ; i < len_data; i++){
  86   2          check ^= T_buf[i];
  87   2        }
  88   1        
  89   1        T_buf[i] = check;
  90   1      }
  91          
  92          
  93          
  94          void send_addr(uchar slave_addr){
  95   1         TI = 0;
  96   1         TB8 = 1;
  97   1         LED=~LED;
  98   1         TXEN;
  99   1         SBUF = slave_addr;
 100   1         while(!TI);
 101   1         TI=0;
 102   1      }
 103          
 104          
 105          
 106          void send_data(){
 107   1        TI = 0;
 108   1        T_done = 0;
 109   1        TXEN;
 110   1        TPtr = 0;
 111   1        TB8 = 0;
 112   1        TI = 1;
 113   1        while(!T_done)
 114   1        T_done = 0; 
 115   1      }
 116          
 117          
C51 COMPILER V9.60.0.0   SLAVE1                                                            05/23/2022 22:18:06 PAGE 3   

 118          
 119          void recv_data(){
 120   1          uint i;
 121   1        
 122   1          RPtr = 0; // 初始化接收
 123   1          R_done = 0;
 124   1          RXEN;
 125   1      
 126   1          while(!R_done); //接收完成后比对校验位
 127   1          R_done = 0;
 128   1           
 129   1          R_check = R_buf[0];
 130   1          for(i = 1; i < len + 3;i++){
 131   2            R_check ^= R_buf[i];
 132   2          }
 133   1          Succ = ~Succ; //用于测试
 134   1         // Succ = (R_check == R_buf[len + 3] ? 1 : 0);
 135   1          
 136   1        //  timer0_init(); // 测试执行mock_data,多长时间；测试表明将近100ms
 137   1          mock_data();  // 根据接收数据，模拟数据
 138   1          
 139   1        //  show_test_data(25); //测试代码
 140   1        //  delay(1000);        
 141   1        //  show_test_data(time_count);
 142   1        //  delay(1000);
 143   1          
 144   1          delay(1000); //同步主机
 145   1          send_data();  //校验后向主机发送数据
 146   1      }
 147          
 148          
 149          
 150          void main(){
 151   1        uint i = 0;
 152   1        serial_init();  // 串口初始化
 153   1        LCD_init();     // LCD显示初始化
 154   1        
 155   1        write_command(0x80); // 光标位置
 156   1        write_data('R');
 157   1        write_data(':');
 158   1        while(1){
 159   2          RI = 0;
 160   2          while(!RI); // 等到触发接收中断时跳出
 161   2          
 162   2          show_test_data(29); //测试代码
 163   2          delay(1000);
 164   2          show_test_data(A_acc);
 165   2          delay(1000);
 166   2          
 167   2          if(R_addr == slave_addr && A_acc){ // 确定地址,A_acc 用于模仿超过七毫秒没有接收到数据   
 168   3            show_test_data(30);
 169   3        //    delay(100);
 170   3            send_addr(slave_addr);
 171   3            SM2 = 0;
 172   3          }else {
 173   3            A_acc = ~A_acc;
 174   3            continue;
 175   3          }       
 176   2      
 177   2          recv_data(); // 接收数据，然后发送数据
 178   2          
 179   2          
C51 COMPILER V9.60.0.0   SLAVE1                                                            05/23/2022 22:18:06 PAGE 4   

 180   2          while(!Succ){ // 如果接收失败重新接收
 181   3            recv_data();
 182   3          }
 183   2          
 184   2          show_data(R_buf[3]); // 数据接收成功，则显示数据
 185   2          
 186   2          RPtr = 0;  //接受主机发送终止请求
 187   2          R_done = 0;
 188   2          RXEN;
 189   2          
 190   2          while(!R_done); //通信结束
 191   2          SM2 = 1;
 192   2        }
 193   1      }
 194          
 195          
 196          void comISR() interrupt 4 { //串口通信中断服务
 197   1        if(RI == 1){  
 198   2          RI = 0;
 199   2          if(RB8 == 0){
 200   3            
 201   3            R_buf[RPtr++] = SBUF;
 202   3                                 
 203   3            show_test_data(23); //测试代码
 204   3            delay(1000);
 205   3            show_test_data(R_buf[RPtr - 1]);
 206   3            delay(1000);
 207   3            
 208   3            if( RPtr >= 4 + R_buf[2]){ //主机地址+从机地址+数据长度+数据+校验和
 209   4              
 210   4              show_test_data(24);  //测试代码
 211   4              delay(1000);
 212   4              show_test_data(RPtr);
 213   4              delay(1000);
 214   4              
 215   4              R_done = 1;
 216   4              len = R_buf[2];
 217   4            }
 218   3          }
 219   2          
 220   2          if(RB8 == 1){
 221   3              R_addr = SBUF;
 222   3          }
 223   2        } 
 224   1        
 225   1        
 226   1        if( TI == 1 && TB8 == 0){
 227   2          TI = 0;
 228   2          
 229   2          if(!T_done){
 230   3            TB8 = 0;
 231   3            SBUF = T_buf[TPtr++];
 232   3            
 233   3            show_test_data(21); //测试代码
 234   3            delay(1000);
 235   3            show_test_data(T_buf[TPtr - 1]);
 236   3            delay(1000);
 237   3            
 238   3            if(TPtr >= T_buf[1] + 3){
 239   4              
 240   4               show_test_data(22); //测试代码
 241   4               delay(1000);
C51 COMPILER V9.60.0.0   SLAVE1                                                            05/23/2022 22:18:06 PAGE 5   

 242   4               show_test_data(TPtr); 
 243   4               delay(1000);
 244   4              
 245   4                T_done = 1;
 246   4                TPtr = 0;
 247   4            }
 248   3          } 
 249   2        }
 250   1      }
 251          
 252          
 253          
 254          void timer0ISR() interrupt 1{ // 定时器0中断服务timer 
 255   1        time_count ++;
 256   1        timer0_init();
 257   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    826    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     31       6
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
